/// Dynamic format string generator for comparison values (in percent)
/// Returns format string with directional indicators based on parameters
function 'DaxLib.FormatString.RelativeToTarget.Percents' =
		
		// Dynamic format string generator for comparison values (in percent)
		// Returns format string with directional indicators based on parameters
		(
		    // Position of comparison symbol
		    // Expects "PREFIX" or "SUFFIX"
		    position: STRING,
		
		    // Number of decimal places
		    // Expects an INT64 value from 0-9
		    decimal_places: INT64,
		
		    // Symbol style - number (1-9) or text:
		    // 1 or "ARROWS": ↑/↓
		    // 2 or "TRIANGLES": ▲/▼
		    // 3 or "PLUSMINUS": +/-
		    // 4 or "CHEVRONS": ˄/˅
		    // 5 or "GREENRED": 🟢/🔴
		    // 6 or "BLUEORANGE": 🔵/🟠
		    // 7 or "BLOCKARROWS": ⬆/⬇
		    // 8 or "CHECKCROSS": ✓/✗
		    // 9 or "NONE": no symbol
		    symbol: ANYVAL,
		
		    // Custom prefix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_prefix: EXPR,
		
		    // Custom suffix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    // Enter " (" & FORMAT ( [PercentMeasure], "0.0%" ) & ")" to add a second value for context
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_suffix: EXPR
		)
		=>
		    VAR _BaseFormat =
		        DaxLib.FormatString.Component.DecimalPlaces( "#,##0", decimal_places ) & "%"
		
		    VAR _Prefix =
		        DaxLib.FormatString.Component.MakeStringSafe ( custom_prefix )
		
		    VAR _Suffix =
		        DaxLib.FormatString.Component.MakeStringSafe ( custom_suffix )
		
		    VAR _PositiveSymbol =
		        DaxLib.FormatString.Component.Symbols ( symbol, "POSITIVE" )
		
		    VAR _NegativeSymbol =
		        DaxLib.FormatString.Component.Symbols ( symbol, "NEGATIVE" )
		
		    VAR _PositiveFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX", _PositiveSymbol & " " & _BaseFormat,
		                "SUFFIX", _BaseFormat & " " & _PositiveSymbol,
		                _BaseFormat & " " & _PositiveSymbol
		            )
		            &
		        _Suffix
		
		    VAR _NegativeFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX", _NegativeSymbol & " " & _BaseFormat,
		                "SUFFIX", _BaseFormat & " " & _NegativeSymbol,
		                _BaseFormat & " " & _NegativeSymbol
		            )
		            &
		        _Suffix
		
		    VAR _ZeroFormat =
		        _Prefix
		            &
		            _BaseFormat
		            &
		        _Suffix
		
		    RETURN
		        _PositiveFormat & ";" & _NegativeFormat & ";" & _ZeroFormat
	lineageTag: 41d68302-703c-4e77-886a-d667c0fa827e

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Convert duration in seconds to HH:MM:SS format string
function 'DaxLib.FormatString.HHMMSS.Seconds' =
		
		// Convert duration in seconds to HH:MM:SS format string
		// To be used on a measure that returns a value in seconds
		() =>
		    VAR _TotalSeconds = SELECTEDMEASURE ()
		
		    VAR _Hours =
		        INT( _TotalSeconds / 3600 )
		
		    VAR _Minutes =
		        INT( MOD( _TotalSeconds, 3600 ) / 60 )
		
		    VAR _Seconds =
		        INT( MOD( _TotalSeconds, 60 ) )
		
		    VAR _Result =
		        DaxLib.FormatString.Component.MakeStringSafe(
		            FORMAT ( _Hours, "00" ) & ":" &
		            FORMAT ( _Minutes, "00" ) & ":" &
		            FORMAT ( _Seconds, "00" )
		        )
		
		    RETURN
		        _Result
	lineageTag: 1516801a-affc-4a32-b883-a645acd52f84

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Convert duration between start and end times to HH:MM:SS format string
function 'DaxLib.FormatString.HHMMSS.StartTimeEndTime' =
		
		// Convert duration between start and end times to HH:MM:SS format string
		(
		    // Start datetime
		    // Include measure, expression, or scalar value
		    startTime: EXPR,
		
		    // End datetime
		    // Include measure, expression, or scalar value
		    endTime: EXPR
		) =>
		    VAR _DurationInSeconds =
		        INT( ( endTime - startTime ) * 86400 )
		
		    VAR _Hours =
		        INT( _DurationInSeconds / 3600 )
		
		    VAR _Minutes =
		        INT( MOD( _DurationInSeconds, 3600 ) / 60 )
		
		    VAR _Seconds =
		        INT( MOD( _DurationInSeconds, 60 ) )
		
		    VAR _Result =
		        DaxLib.FormatString.Component.MakeStringSafe(
		            FORMAT ( _Hours, "00" ) & ":" &
		            FORMAT ( _Minutes, "00" ) & ":" &
		            FORMAT ( _Seconds, "00" )
		        )
		
		    RETURN
		        _Result
	lineageTag: b8272f03-ec9e-4a84-9495-0167c828e0e8

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Dynamic format string with automatic K/M/bn/tn suffix, rounding, and decimal places based on value magnitude
/// Supports dynamic currency conversion
function 'DaxLib.FormatString.DynamicUnits' =
		
		// Dynamic format string with automatic K/M/bn/tn suffix, rounding, and decimal places based on value magnitude
		// Supports dynamic currency conversion
		(
		    // The value to format
		    // Expects a numeric value or measure reference
		    // Recommended: SELECTEDMEASURE()
		    format_value: EXPR,
		
		    // The currency symbol you want to use
		    // Expects a symbol like "$"
		    // Enter "" for none
		    // Use DaxLib.FormatString.Component.GetCurrencySymbol for dynamic currency conversion
		    currency_symbol: STRING,
		
		    // Whether the currency should be a prefix or suffix
		    // Expects "PREFIX" or "SUFFIX"
		    // Enter "" for none
		    // Use DaxLib.FormatString.Component.GetCurrencyPosition for dynamic currency conversion
		    currency_position: STRING,
		
		    // Custom prefix (optional)
		    // Enter "" for none
		    // Note: Value is string-safe; no need for """"
		    custom_prefix : EXPR,
		
		    // Custom suffix (optional)
		    // Enter "" for none
		    // Note: Value is string-safe; no need for """"
		    custom_suffix : EXPR
		)
		=>
		    VAR _NumberFormat =
		        DaxLib.FormatString.Component.DynamicUnits( "#,##0", format_value )
		
		    VAR _CurrencySymbol =
		        currency_symbol
		
		    VAR _CurrencyPosition =
		        currency_position
		
		    VAR _Prefix =
		        IF ( _CurrencyPosition = "PREFIX", _CurrencySymbol & " ", "" ) &
		        DaxLib.FormatString.Component.MakeStringSafe( custom_prefix )
		
		    VAR _Suffix =
		        IF ( _CurrencyPosition = "SUFFIX", " " & _CurrencySymbol, "" ) &
		        DaxLib.FormatString.Component.MakeStringSafe( custom_suffix )
		
		    VAR _FormatString =
		        _Prefix & _NumberFormat & _Suffix
		
		    RETURN
		        _FormatString
	lineageTag: f140e89e-860c-4bb7-a528-638d5e63d47d

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get comparison symbol based on style and value sign
/// Returns appropriate symbol for positive, negative, or zero values
function 'DaxLib.FormatString.Component.Symbols' =
		
		// Get comparison symbol based on style and value sign
		// Returns appropriate symbol for positive, negative, or zero values
		(
		    // Symbol style - number (1-9) or text:
		    // 1 or "ARROWS": ↑/↓
		    // 2 or "TRIANGLES": ▲/▼
		    // 3 or "PLUSMINUS": +/-
		    // 4 or "CHEVRONS": ˄/˅
		    // 5 or "GREENRED": 🟢/🔴
		    // 6 or "BLUEORANGE": 🔵/🟠
		    // 7 or "BLOCKARROWS": ⬆/⬇
		    // 8 or "CHECKCROSS": ✓/✗
		    // 9 or "NONE": no symbol
		    symbol_style: ANYVAL,
		
		    // Value type: "POSITIVE", "NEGATIVE", or "ZERO"
		    value_type: STRING
		)
		=>
		    VAR _SymbolCode =
		        IF ( ISNUMBER ( symbol_style ),
		            symbol_style,
		            SWITCH ( UPPER ( symbol_style ),
		                "ARROWS", 1,
		                "TRIANGLES", 2,
		                "PLUSMINUS", 3,
		                "CHEVRONS", 4,
		                "GREENRED", 5,
		                "BLUEORANGE", 6,
		                "BLOCKARROWS", 7,
		                "CHECKCROSS", 8,
		                "NONE", 9,
		                9
		            )
		        )
		
		    VAR _Symbol =
		        SWITCH ( value_type,
		            "POSITIVE",
		                SWITCH ( _SymbolCode,
		                    1, "↑",
		                    2, "▲",
		                    3, "+",
		                    4, "˄",
		                    5, "🟢",
		                    6, "🔵",
		                    7, "⬆",
		                    8, "✓",
		                    9, "",
		                    ""
		                ),
		            "NEGATIVE",
		                SWITCH ( _SymbolCode,
		                    1, "↓",
		                    2, "▼",
		                    3, "-",
		                    4, "˅",
		                    5, "🔴",
		                    6, "🟠",
		                    7, "⬇",
		                    8, "✗",
		                    9, "",
		                    ""
		                ),
		            ""
		        )
		
		    RETURN
		        _Symbol
	lineageTag: 811db3c2-916f-4c93-8a00-e21e6dd5f539

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Returns a 0 string repeated a number of times equal to the number of decimal places
function 'DaxLib.FormatString.Component.DecimalPlaces' =
		
		// Returns a 0 string repeated a number of times equal to the number of decimal places
		(
		    // Base format string
		    // Expects a valid format string base, i.e. "#,##0"
		    base_format: STRING,
		
		    // Number of decimal places
		    // Expects an integer value from 0-9
		    decimal_places: INT64
		)
		=>
		    base_format
		    &
		    IF (
		        decimal_places > 0,
		        "."
		            & REPT ( "0", MIN ( decimal_places, 9 ) ),
		        ""
		    )
	lineageTag: 2c2336c1-0f25-4886-9de0-0f4675a48497

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Wraps strings in double-quotes to avoid issues with format string interpretation
function 'DaxLib.FormatString.Component.MakeStringSafe' =
		
		// Wraps strings in double-quotes to avoid issues with format string interpretation
		(
		    // The value you want to put in the format string
		    unsafe_string : STRING
		)
		=>
		    """" & unsafe_string & """"
	lineageTag: 58e5df7d-1f5b-4223-af82-73d444281d7d

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get currency format string based on currency code
/// Returns appropriate number format with currency symbol placement
function 'DaxLib.FormatString.DynamicCurrency' =
		
		// Get currency format string based on currency code
		// Returns appropriate number format with currency symbol placement
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    // Expects a column reference used for selecting a currency in the report, like 'Exchange Rate'[Currency Code]
		    currency_code: ANYREF,
		
		    // Base format string
		    // Recommended: "#,##0"
		    decimal_places: INT64
		)
		=>
		    VAR _BaseFormat =
		        DaxLib.FormatString.Component.DecimalPlaces( "#,##0", decimal_places )
		
		    VAR _CurrencyPosition =
		        DaxLib.FormatString.Component.GetCurrencyPosition ( currency_code )
		
		    VAR _CurrencySymbol =
		        DaxLib.FormatString.Component.GetCurrencySymbol ( currency_code )
		
		    VAR _Prefix =
		        IF ( _CurrencyPosition = "PREFIX", _CurrencySymbol & " ", "" )
		
		    VAR _Suffix =
		        IF ( _CurrencyPosition = "SUFFIX", " " & _CurrencySymbol, "" )
		
		    VAR _Format =
		        _Prefix & _BaseFormat & _Suffix
		
		    RETURN
		        _Format
	lineageTag: 8e523e4f-7e0c-4fcc-bc3a-ce829a521a38

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get currency symbol based on currency code
/// Returns currency symbol as a string (e.g., "$" or "€")
function 'DaxLib.FormatString.Component.GetCurrencySymbol' =
		
		// Get currency symbol based on currency code
		// Returns currency symbol as a string (e.g., "$" or "€")
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )
		
		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            DaxLib.FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )
		
		    VAR _Symbol =
		        SELECTCOLUMNS ( _Currency, ''[Currency Symbol] )
		
		    RETURN
		        _Symbol
	lineageTag: 88725dfb-018c-4c4e-9d51-bfcf103bfc60

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get currency position based on currency code
/// Returns either "PREFIX" or "SUFFIX"
function 'DaxLib.FormatString.Component.GetCurrencyPosition' =
		
		// Get currency position based on currency code
		// Returns either "PREFIX" or "SUFFIX"
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )
		
		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            DaxLib.FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )
		
		    VAR _Position =
		        SELECTCOLUMNS ( _Currency, ''[Currency Position] )
		
		    RETURN
		        _Position
	lineageTag: ed510846-a6ee-49e2-a2eb-81ffc303a30b

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Helper function to dynamically round and format values
function 'DaxLib.FormatString.Component.DynamicUnits' =
		
		// Helper function to dynamically round and format values
		(
		    // Base format string
		    base_format: STRING,
		    // Expects a valid format string base, i.e. "#,##0"
		
		    // The value to format
		    // EXPR because it must be able to handle SELECTEDMEASURE() and arbitrary expressions
		    format_value: EXPR
		)
		=>
		    VAR _CurrentValue =
		        format_value
		
		    VAR _Format =
		        base_format &
		        SWITCH (
		            TRUE (),
		            _CurrentValue <= 1E3, ".",
		            _CurrentValue <= 1E4, ",.00 K",
		            _CurrentValue <= 1E5, ",.0 K",
		            _CurrentValue <= 1E6, ",. K",
		            _CurrentValue <= 1E7, ",,.00 M",
		            _CurrentValue <= 1E8, ",,.0 M",
		            _CurrentValue <= 1E9, ",,. M",
		            _CurrentValue <= 1E10, ",,,.00 bn",
		            _CurrentValue <= 1E11, ",,,.0 bn",
		            _CurrentValue <= 1E12, ",,,,. bn",
		            _CurrentValue <= 1E13, ",,,,.00 tn",
		            _CurrentValue <= 1E14, ",,,,,.0 tn",
		            _CurrentValue <= 1E15, ",,,,,. tn"
		        )
		    RETURN
		        _Format
	lineageTag: 628aba22-267f-4083-b727-860310aa358b

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Dynamic format string generator for comparison values (in value)
/// Returns format string with directional indicators based on parameters
function 'DaxLib.FormatString.RelativeToTarget.Numeric' =
		
		// Dynamic format string generator for comparison values (in value)
		// Returns format string with directional indicators based on parameters
		(
		    // Position of comparison symbol
		    // Expects "PREFIX" or "SUFFIX"
		    position: STRING,
		
		    // Number of decimal places
		    // Expects an INT64 value from 0-9
		    decimal_places: INT64,
		
		    // Symbol style - number (1-9) or text:
		    // 1 or "ARROWS": ↑/↓
		    // 2 or "TRIANGLES": ▲/▼
		    // 3 or "PLUSMINUS": +/-
		    // 4 or "CHEVRONS": ˄/˅
		    // 5 or "GREENRED": 🟢/🔴
		    // 6 or "BLUEORANGE": 🔵/🟠
		    // 7 or "BLOCKARROWS": ⬆/⬇
		    // 8 or "CHECKCROSS": ✓/✗
		    // 9 or "NONE": no symbol
		    symbol: ANYVAL,
		
		    // Custom prefix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_prefix: EXPR,
		
		    // Custom suffix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    // Enter " (" & FORMAT ( [PercentMeasure], "0.0%" ) & ")" to add a second value for context
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_suffix: EXPR
		) =>
		    VAR _BaseFormat =
		        DaxLib.FormatString.Component.DecimalPlaces( "#,##0", decimal_places )
		
		    VAR _Prefix =
		        DaxLib.FormatString.Component.MakeStringSafe ( custom_prefix )
		
		    VAR _Suffix =
		        DaxLib.FormatString.Component.MakeStringSafe ( custom_suffix )
		
		    VAR _PositiveSymbol =
		        DaxLib.FormatString.Component.Symbols ( symbol, "POSITIVE" )
		
		    VAR _NegativeSymbol =
		        DaxLib.FormatString.Component.Symbols ( symbol, "NEGATIVE" )
		
		    VAR _PositiveFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX",
		                    _PositiveSymbol & " " & _BaseFormat,
		                "SUFFIX",
		                    _BaseFormat & " " & _PositiveSymbol,
		                _BaseFormat & " " & _PositiveSymbol
		            )
		            & _Suffix
		
		    VAR _NegativeFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX",
		                    _NegativeSymbol & " " & _BaseFormat,
		                "SUFFIX",
		                    _BaseFormat & " " & _NegativeSymbol,
		                _BaseFormat & " " & _NegativeSymbol
		            )
		            & _Suffix
		
		    VAR _ZeroFormat =
		        _Prefix & _BaseFormat & _Suffix
		
		    RETURN
		        _PositiveFormat & ";" & _NegativeFormat
		            & ";"
		            & _ZeroFormat
	lineageTag: fe74ae06-0eb9-467b-adcb-75d95da431c4

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get currency reference table with codes, symbols, position, and format strings
/// Returns table with currency metadata for use in other calculations
function 'DaxLib.FormatString.Component.CurrencyTable' =
		
		// Get currency reference table with codes, symbols, position, and format strings
		// Returns table with currency metadata for use in other calculations
		()
		=>
		    VAR _CurrencyTable =
		        DATATABLE (
		            "Currency Code", STRING,
		            "Currency Symbol", STRING,
		            "Currency Position", STRING,
		            "Format String", STRING,
		            "Format String PNZ", STRING,
		            {
		                -- Major currencies
		                { "CAD", "C$", "PREFIX", "C$#,##0", "C$#,##0;-C$#,##0;C$0" },
		                { "EUR", "€", "SUFFIX", "#,##0 €", "#,##0 €;-#,##0 €;0 €" },
		                { "GBP", "£", "PREFIX", "£#,##0", "£#,##0;-£#,##0;£0" },
		                { "JPY", "¥", "PREFIX", "¥#,##0", "¥#,##0;-¥#,##0;¥0" },
		                { "CHF", "CHF", "PREFIX", "CHF #,##0", "CHF #,##0;-CHF #,##0;CHF 0" },
		
		                -- Dollar variants
		                { "USD", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "AUD", "A$", "PREFIX", "A$#,##0", "A$#,##0;-A$#,##0;A$0" },
		                { "NZD", "NZ$", "PREFIX", "NZ$#,##0", "NZ$#,##0;-NZ$#,##0;NZ$0" },
		                { "HKD", "HK$", "PREFIX", "HK$#,##0", "HK$#,##0;-HK$#,##0;HK$0" },
		                { "SGD", "S$", "PREFIX", "S$#,##0", "S$#,##0;-S$#,##0;S$0" },
		                { "TWD", "NT$", "PREFIX", "NT$#,##0", "NT$#,##0;-NT$#,##0;NT$0" },
		
		                -- Asian currencies
		                { "CNY", "¥", "PREFIX", "¥#,##0", "¥#,##0;-¥#,##0;¥0" },
		                { "INR", "₹", "PREFIX", "₹#,##0", "₹#,##0;-₹#,##0;₹0" },
		                { "KRW", "₩", "PREFIX", "₩#,##0", "₩#,##0;-₩#,##0;₩0" },
		                { "THB", "฿", "PREFIX", "฿#,##0", "฿#,##0;-฿#,##0;฿0" },
		                { "PHP", "₱", "PREFIX", "₱#,##0", "₱#,##0;-₱#,##0;₱0" },
		                { "IDR", "Rp", "PREFIX", "Rp#,##0", "Rp#,##0;-Rp#,##0;Rp0" },
		                { "MYR", "RM", "PREFIX", "RM#,##0", "RM#,##0;-RM#,##0;RM0" },
		                { "VND", "₫", "PREFIX", "₫#,##0", "₫#,##0;-₫#,##0;₫0" },
		                { "PKR", "Rs", "PREFIX", "Rs#,##0", "Rs#,##0;-Rs#,##0;Rs0" },
		                { "BDT", "৳", "PREFIX", "৳#,##0", "৳#,##0;-৳#,##0;৳0" },
		                { "LKR", "Rs", "PREFIX", "Rs#,##0", "Rs#,##0;-Rs#,##0;Rs0" },
		                { "RUB", "₽", "PREFIX", "₽#,##0", "₽#,##0;-₽#,##0;₽0" },
		                { "UAH", "₴", "PREFIX", "₴#,##0", "₴#,##0;-₴#,##0;₴0" },
		                { "KZT", "₸", "PREFIX", "₸#,##0", "₸#,##0;-₸#,##0;₸0" },
		                { "BYN", "Br", "PREFIX", "Br#,##0", "Br#,##0;-Br#,##0;Br0" },
		                { "UZS", "soʻm", "SUFFIX", "#,##0 soʻm", "#,##0 soʻm;-#,##0 soʻm;0 soʻm" },
		                { "AZN", "₼", "PREFIX", "₼#,##0", "₼#,##0;-₼#,##0;₼0" },
		                { "GEL", "₾", "PREFIX", "₾#,##0", "₾#,##0;-₾#,##0;₾0" },
		                { "AMD", "֏", "PREFIX", "֏#,##0", "֏#,##0;-֏#,##0;֏0" },
		
		                -- European currencies
		                { "SEK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		                { "NOK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		                { "DKK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		                { "PLN", "zł", "SUFFIX", "#,##0 zł", "#,##0 zł;-#,##0 zł;0 zł" },
		                { "HUF", "Ft", "SUFFIX", "#,##0 Ft", "#,##0 Ft;-#,##0 Ft;0 Ft" },
		                { "CZK", "Kč", "SUFFIX", "#,##0 Kč", "#,##0 Kč;-#,##0 Kč;0 Kč" },
		                { "RON", "lei", "SUFFIX", "#,##0 lei", "#,##0 lei;-#,##0 lei;0 lei" },
		                { "BGN", "лв", "SUFFIX", "#,##0 лв", "#,##0 лв;-#,##0 лв;0 лв" },
		                { "HRK", "kn", "SUFFIX", "#,##0 kn", "#,##0 kn;-#,##0 kn;0 kn" },
		                { "ISK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		
		                -- Latin American
		                { "MXN", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "BRL", "R$", "PREFIX", "R$#,##0", "R$#,##0;-R$#,##0;R$0" },
		                { "CLP", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "COP", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "ARS", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "PEN", "S/", "PREFIX", "S/#,##0", "S/#,##0;-S/#,##0;S/0" },
		                { "UYU", "$U", "PREFIX", "$U#,##0", "$U#,##0;-$U#,##0;$U0" },
		                { "BOB", "Bs", "PREFIX", "Bs#,##0", "Bs#,##0;-Bs#,##0;Bs0" },
		                { "PYG", "₲", "PREFIX", "₲#,##0", "₲#,##0;-₲#,##0;₲0" },
		                { "VES", "Bs", "PREFIX", "Bs#,##0", "Bs#,##0;-Bs#,##0;Bs0" },
		                { "GTQ", "Q", "PREFIX", "Q#,##0", "Q#,##0;-Q#,##0;Q0" },
		                { "CRC", "₡", "PREFIX", "₡#,##0", "₡#,##0;-₡#,##0;₡0" },
		                { "DOP", "RD$", "PREFIX", "RD$#,##0", "RD$#,##0;-RD$#,##0;RD$0" },
		                { "CUP", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		
		                -- Middle Eastern & African
		                { "TRY", "₺", "PREFIX", "₺#,##0", "₺#,##0;-₺#,##0;₺0" },
		                { "ILS", "₪", "PREFIX", "₪#,##0", "₪#,##0;-₪#,##0;₪0" },
		                { "AED", "AED", "PREFIX", "AED #,##0", "AED #,##0;-AED #,##0;AED 0" },
		                { "SAR", "SAR", "PREFIX", "SAR #,##0", "SAR #,##0;-SAR #,##0;SAR 0" },
		                { "QAR", "QR", "PREFIX", "QR #,##0", "QR #,##0;-QR #,##0;QR 0" },
		                { "KWD", "KD", "PREFIX", "KD #,##0", "KD #,##0;-KD #,##0;KD 0" },
		                { "BHD", "BD", "PREFIX", "BD #,##0", "BD #,##0;-BD #,##0;BD 0" },
		                { "OMR", "OMR", "PREFIX", "OMR #,##0", "OMR #,##0;-OMR #,##0;OMR 0" },
		                { "JOD", "JD", "PREFIX", "JD #,##0", "JD #,##0;-JD #,##0;JD 0" },
		                { "EGP", "E£", "PREFIX", "E£#,##0", "E£#,##0;-E£#,##0;E£0" },
		                { "MAD", "MAD", "PREFIX", "MAD #,##0", "MAD #,##0;-MAD #,##0;MAD 0" },
		                { "ZAR", "R", "PREFIX", "R #,##0", "R #,##0;-R #,##0;R 0" },
		                { "NGN", "₦", "PREFIX", "₦#,##0", "₦#,##0;-₦#,##0;₦0" },
		                { "KES", "KSh", "PREFIX", "KSh#,##0", "KSh#,##0;-KSh#,##0;KSh0" },
		                { "GHS", "GH₵", "PREFIX", "GH₵#,##0", "GH₵#,##0;-GH₵#,##0;GH₵0" },
		                { "TND", "DT", "PREFIX", "DT #,##0", "DT #,##0;-DT #,##0;DT 0" },
		                { "ETB", "Br", "PREFIX", "Br#,##0", "Br#,##0;-Br#,##0;Br0" },
		
		                -- SpaceParts fictional currencies
		                { "ARC", "₳", "PREFIX", "₳ #,##0", "₳ #,##0;-₳ #,##0;₳ 0" },
		                { "BELT", "฿", "PREFIX", "฿ #,##0", "฿ #,##0;-฿ #,##0;฿ 0" },
		                { "BLO", "Ł", "SUFFIX", "#,##0 Ł", "#,##0 Ł;-#,##0 Ł;0 Ł" },
		                { "BLT", "₺", "PREFIX", "₺ #,##0", "₺ #,##0;-₺ #,##0;₺ 0" },
		                { "CAL", "¢", "SUFFIX", "#,##0 ¢", "#,##0 ¢;-#,##0 ¢;0 ¢" },
		                { "CREDITS", "₡", "PREFIX", "₡ #,##0", "₡ #,##0;-₡ #,##0;₡ 0" },
		                { "ELD", "Ξ", "SUFFIX", "#,##0 Ξ", "#,##0 Ξ;-#,##0 Ξ;0 Ξ" },
		                { "HAL", "Ħ", "PREFIX", "Ħ #,##0", "Ħ #,##0;-Ħ #,##0;Ħ 0" },
		                { "ILOS", "ł", "SUFFIX", "#,##0 ł", "#,##0 ł;-#,##0 ł;0 ł" },
		                { "LAK", "₭", "PREFIX", "₭ #,##0", "₭ #,##0;-₭ #,##0;₭ 0" },
		                { "MCR", "₥", "PREFIX", "₥ #,##0", "₥ #,##0;-₥ #,##0;₥ 0" },
		                { "OTN", "Ø", "PREFIX", "Ø #,##0", "Ø #,##0;-Ø #,##0;Ø 0" },
		                { "UPN", "Ʉ", "SUFFIX", "#,##0 Ʉ", "#,##0 Ʉ;-#,##0 Ʉ;0 Ʉ" }
		            }
		        )
		
		    RETURN
		        _CurrencyTable
	lineageTag: 8a89e1c0-aaa6-4446-8653-8e8359d2482c

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get currency format based on currency code
/// Returns simple currency format string (i.e. $#,##0.0)
function 'DaxLib.FormatString.Component.GetCurrencyFormat' =
		
		// Get currency format based on currency code
		// Returns simple currency format string (i.e. $#,##0.0)
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )
		
		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            DaxLib.FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )
		
		    VAR _Symbol =
		        SELECTCOLUMNS ( _Currency, ''[Format String] )
		
		    RETURN
		        _Symbol
	lineageTag: 2bca491d-1621-4fd8-845a-c4addec4fc5c

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Get currency format based on currency code
/// Returns positive; negative; zero format string (i.e. $#,##0.0; ($-#,##0.0); $0)
function 'DaxLib.FormatString.Component.GetCurrencyFormat.PNZ' =
		
		// Get currency format based on currency code
		// Returns positive; negative; zero format string (i.e. $#,##0.0; ($-#,##0.0); $0)
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )
		
		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            DaxLib.FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )
		
		    VAR _Symbol =
		        SELECTCOLUMNS ( _Currency, ''[Format String PNZ] )
		
		    RETURN
		        _Symbol
	lineageTag: ae9603db-bf01-4c9b-a3fe-138cef84c666

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Simple function to centralize date formats in a model
/// Main benefit is that if you want to change it, you only have to do it in one place
/// 
/// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every Date field.
function 'DaxLib.FormatString.Basic.Dates' =
		
		// Simple function to centralize date formats in a model.
		// Main benefit is that if you want to change it, you only have to do it in one place.
		//
		// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every Date field.
		() =>
		    // Replace with one of the other, commented options, below.
		
		    -- e.g. 2025-12-25 (ISO 8601 - International Standard)
		    -- "yyyy-MM-dd"
		
		    -- e.g. 12/25/2025 (Confusing Format)
		    -- "MM/dd/yyyy"
		
		    -- e.g. 25/12/2025 (European/UK Format)
			"dd/MM/yyyy"
		
		    -- e.g. Dec 25, 2025 (Abbreviated Month)
		    -- "MMM dd, yyyy"
		
		    -- e.g. Dec 25, 2025 (Abbreviated Month and Year)
		    -- "MMM dd, 'yy"
		
		    -- e.g. December 25, 2025 (Full Month Name)
		    -- "MMMM dd, yyyy"
		
		    -- e.g. 25-Dec-2025 (Day-Month-Year with Dashes)
		    -- "dd-MMM-yyyy"
		
		    -- e.g. 25 Dec 2025 (Day Month Year with Spaces)
		    -- "dd MMM yyyy"
		
		    -- e.g. Thursday, December 25, 2025 (Full Day and Month Names)
		    -- "dddd, MMMM DD, yyyy"
		
		    -- e.g. Thu, Dec 25, 2025 (Abbreviated Day Name)
		    -- "ddd, MMM DD, yyyy"
		
		    -- e.g. 25.12.2025 (European Format with Dots)
		    -- "dd.MM.yyyy"
	lineageTag: 12adc1df-2acf-4da9-9ee1-9664eb2c4b23

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Simple function to centralize month formats in a model
/// Main benefit is that if you want to change it, you only have to do it in one place
/// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every Month field.
function 'DaxLib.FormatString.Basic.Months' =
		
		// Simple function to centralize month formats in a model.
		// Main benefit is that if you want to change it, you only have to do it in one place.
		//
		// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every Month field.
		( ) => "yyyy-MM"
		
		    -- e.g. Dec 2025 (Abbreviated Month Year)
		    -- "MMM yyyy"
		
		    -- e.g. December 2025 (Full Month Name with Year)
		    -- "MMMM yyyy"
		
		    -- e.g. 12/2025 (Numeric Month/Year)
		    -- "MM/yyyy"
		
		    -- e.g. 2025/12 (Year/Month for Sorting)
		    -- "yyyy/MM"
		
		    -- e.g. 2025 Dec (Year First with Abbreviated Month)
		    -- "yyyy MMM"
		
		    -- e.g. 2025 M12 (Year with 'M' Month Indicator)
		    -- Note: quad-quotes necessary to avoid "M" being interpreted as a month number
		    -- "yyyy" & """" & "M" & """" & "MM"
		
		    -- e.g. Dec-25 (Abbreviated Month-Year Short)
		    -- "MMM-yy"
		
		    -- e.g. 12-2025 (Month-Year with Dash)
		    -- "MM-yyyy"
		
		    -- e.g. 2025.12 (Year.Month with Dot)
		    -- "yyyy.MM"
	lineageTag: b70f7a36-1089-4df5-a056-fb70aa24ead5

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Simple function to centralize datetime formats in a model.
/// Main benefit is that if you want to change it, you only have to do it in one place.
/// 
/// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every DateTime field.
function 'DaxLib.FormatString.Basic.DateTimes' =
		
		// Simple function to centralize datetime formats in a model.
		// Main benefit is that if you want to change it, you only have to do it in one place.
		//
		// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every DateTime field.
		( ) => "yyyy-MM-dd HH:mm:ss"
		
		    -- e.g. 12/25/2025 2:30 PM (US Format with 12-hour Time)
		    -- "MM/dd/yyyy h:mm AM/PM"
		
		    -- e.g. 25/12/2025 14:30 (European Format with 24-hour Time)
		    -- "dd/MM/yyyy HH:mm"
		
		    -- e.g. Dec 25, 2025 2:30:45 PM (Abbreviated Month with Full Time)
		    -- "MMM dd, yyyy h:mm:ss AM/PM"
		
		    -- e.g. 2025-12-25T14:30:00 (ISO 8601 Standard with T Separator)
		    -- "yyyy-MM-dd\THH:mm:ss"
		
		    -- e.g. 25-Dec-2025 14:30 (Day-Month-Year with Time)
		    -- "dd-MMM-yyyy HH:mm"
		
		    -- e.g. December 25, 2025 at 2:30 PM (Full Month with "at")
		    -- "MMMM dd, yyyy \a\t h:mm AM/PM"
		
		    -- e.g. Thu, Dec 25, 2025 14:30:00 (Abbreviated Day with Full Time)
		    -- "ddd, MMM dd, yyyy HH:mm:ss"
		
		    -- e.g. 2025-12-25 14:30 (Compact ISO Format)
		    -- "yyyy-MM-dd HH:mm"
		
		    -- e.g. 12/25 2:30 PM (Short Format without Year)
		    -- "MM/dd h:mm AM/PM"
	lineageTag: 020976f6-1362-4065-9419-a7e8a4815974

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Simple function to centralize quarter formats in a model.
/// Main benefit is that if you want to change it, you only have to do it in one place.
/// 
/// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every Quarter field.
function 'DaxLib.FormatString.Basic.Quarters' =
		
		// Simple function to centralize quarter formats in a model.
		// Main benefit is that if you want to change it, you only have to do it in one place.
		//
		// Recommended: Use a Tabular Editor Macro to assign this function to the format string of every Quarter field.
		( ) =>
		    VAR _Q = "Q"
		    VAR _Qtr = "Qtr"
		    VAR _FY = "FY"
		    VAR _Quarter = QUARTER ( SELECTEDMEASURE () )
		
		    VAR _Format =
		        // Replace with one of the other, commented options, below.
		
		        -- e.g. 2025 Q4 (Year Quarter - Most Common)
		        "yyyy " & _Q & _Quarter
		
		        -- e.g. Q4 2025 (Quarter Year)
		        -- _Q  & _Quarter & "yyyy"
		
		        -- e.g. 2025-Q4 (Year-Quarter with Dash)
		        -- "yyyy-" & _Q & _Quarter
		
		        -- e.g. Q4/2025 (Quarter/Year with Slash)
		        -- _Q & _Quarter & "/yyyy"
		
		        -- e.g. 2025 Qtr 4 (Year with "Qtr" Abbreviation)
		        -- "yyyy " & _Qtr & _Quarter
		
		        -- e.g. FY2025 Q4 (Fiscal Year Quarter)
		        -- _FY & "yyyy " & _Q & _Quarter
		
		        -- e.g. 25 Q4 (Short Year Quarter)
		        -- "YY " & _Q & _Quarter
		
		        -- e.g. 2025Q4 (Compact Format)
		        -- "yyyy" & _Q & _Quarter
		
		        -- e.g. Q4-25 (Quarter-Short Year)
		        -- _Q & _Quarter & "-yy"
		
		        -- e.g. 4Q 2025 (Number Q Year)
		        --  _Quarter & _Q & " yyyy"
		
		    RETURN
		        _Format
	lineageTag: 4113b20a-ee68-4ab1-a352-a8e4f27d4b98

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Generic number format function with configurable decimal places.
/// Centralizes number formatting logic for consistency across the model.
/// 
/// Recommended: Use for all numeric measures where decimal precision needs to be standardized.
function 'DaxLib.FormatString.Basic.Numbers' =
		
		// Generic number format function with configurable decimal places.
		// Centralizes number formatting logic for consistency across the model.
		//
		// Recommended: Use for all numeric measures where decimal precision needs to be standardized.
		( ) => DaxLib.FormatString.Component.DecimalPlaces ( "#,##0", 0 )
	lineageTag: def5e5c5-3e7b-43ba-913b-d78878174c43

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Generic number format function with configurable decimal places.
/// Centralizes number formatting logic for consistency across the model.
/// 
/// Recommended: Use for all numeric measures where decimal precision needs to be standardized.
function 'DaxLib.FormatString.Basic.Percents' =
		
		// Generic number format function with configurable decimal places.
		// Centralizes number formatting logic for consistency across the model.
		//
		// Recommended: Use for all numeric measures where decimal precision needs to be standardized.
		( ) => DaxLib.FormatString.Component.DecimalPlaces ( "#,##0", 0 ) & "%"
	lineageTag: 430d73d9-608b-466b-a13f-76cbe5251012

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Generic number format function with configurable decimal places.
/// Centralizes number formatting logic for consistency across the model.
/// 
/// Recommended: Use in limited scenarios when you want more optimal control over number rounding than what Power BI provides.
function 'DaxLib.FormatString.Basic.SmarterRounding' =
		
		// Generic number format function with configurable decimal places.
		// Centralizes number formatting logic for consistency across the model.
		//
		// Recommended: Use in limited scenarios when you want more optimal control over number rounding than what Power BI provides.
		( ) => DaxLib.FormatString.Component.DynamicUnits ( "#,##0", SELECTEDMEASURE () )
	lineageTag: 5b6b94f7-759b-4d77-a24d-2e9af9175fc1

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Format file sizes with automatic unit detection
/// Returns human-readable format like "1.2 GB", "512 MB", "2.3 KB"
function 'DaxLib.FormatString.Basic.FileSize' =
		
		// Format file sizes with automatic unit detection
		// Returns human-readable format like "1.2 GB", "512 MB", "2.3 KB"
		() =>
		    VAR _Bytes = ABS( SELECTEDMEASURE () )
		
		    VAR _Unit =
		        SWITCH (
		            TRUE (),
		            _Bytes >= 1099511627776, " TB",
		            _Bytes >= 1073741824, " GB",
		            _Bytes >= 1048576, " MB",
		            _Bytes >= 1024, " KB",
		            " bytes"
		        )
		
		    VAR _Value =
		        SWITCH (
		            TRUE (),
		            _Bytes >= 1099511627776, _Bytes / 1099511627776,
		            _Bytes >= 1073741824, _Bytes / 1073741824,
		            _Bytes >= 1048576, _Bytes / 1048576,
		            _Bytes >= 1024, _Bytes / 1024,
		            _Bytes
		        )
		
		    VAR _Decimals =
		        IF ( _Unit = " bytes", 0, 1 )
		
		    VAR _FormatString =
		        IF ( _Decimals = 0, "#,##0", "#,##0.0" )
		
		    VAR _Result =
		        -- Avoids values or units being interpreted as part of the format string
		        DaxLib.FormatString.Component.MakeStringSafe(
		            FORMAT ( _Value, _FormatString ) & _Unit
		        )
		
		    RETURN
		        _Result
	lineageTag: 5b6ae216-4df7-4e8e-bd9f-2a47029ef427

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Format temperature values with unit symbols
/// Returns formatted temperature like "23.5°C", "75°F"
/// 
/// WARNING: Doesn't convert units
function 'DaxLib.FormatString.Basic.Temperature' =
		
		// Format temperature values with unit symbols
		// Returns formatted temperature like "23.5°C", "75°F"
		//
		// WARNING: Doesn't convert units
		(
		    // Temperature unit: "C" for Celsius, "F" for Fahrenheit
		    unit: STRING,
		
		    // Number of decimal places (0-2)
		    decimal_places: INT64
		) =>
		    VAR _Unit =
		        SWITCH (
		            UPPER( unit ),
		            "C", "°C",
		            "F", "°F",
		            "°"
		        )
		
		    VAR _Format =
		        DaxLib.FormatString.Component.DecimalPlaces (
		            "#,##0",
		            decimal_places
		        )
		        & " " & _Unit
		
		    RETURN
		        _Format
	lineageTag: cfd4ab06-6653-4050-9481-ca286e075dfe

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Convert numbers to ordinal format
/// Returns ordinal numbers like "1st", "2nd", "3rd", "21st"
function 'DaxLib.FormatString.Basic.Ordinals' =
		
		// Convert numbers to ordinal format
		// Returns ordinal numbers like "1st", "2nd", "3rd", "21st"
		() =>
		    VAR _Num = ABS( SELECTEDMEASURE () )
		    VAR _LastDigit = MOD( _Num, 10 )
		    VAR _LastTwoDigits = MOD( _Num, 100 )
		
		    VAR _Suffix =
		        SWITCH (
		            TRUE (),
		            _LastTwoDigits >= 11 && _LastTwoDigits <= 13, "th",
		            _LastDigit = 1, "st",
		            _LastDigit = 2, "nd",
		            _LastDigit = 3, "rd",
		            "th"
		        )
		
		    RETURN
		       "#,##0" & _Suffix
	lineageTag: 7fb9f456-35f5-4cbe-a0a0-2f97a8c3aff2

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Format numbers in scientific notation
/// Returns scientific notation like "1.23E+06", "4.56E-03"
function 'DaxLib.FormatString.Basic.Scientific' =
		
		// Format numbers in scientific notation
		// Returns scientific notation like "1.23E+06", "4.56E-03"
		(
		    // Number of decimal places (1-15)
		    decimal_places: INT64
		) =>
		    VAR _Decimals = MAX( 1, MIN( decimal_places, 15 ) )
		    VAR _Notation = "0." & REPT( "0", _Decimals ) & "E+00"
		    VAR _Format =
		        DaxLib.FormatString.Component.MakeStringSafe (
		            FORMAT( SELECTEDMEASURE (), _Notation )
		        )
		
		    RETURN
		        _Format
	lineageTag: 915cf599-e3e2-456b-862e-d01ec320db08

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Handle pluralization based on count values
/// Returns singular or plural forms like "1 item" vs "2 items"
function 'DaxLib.FormatString.Component.Pluralization' =
		
		// Handle pluralization based on count values
		// Returns singular or plural forms like "1 item" vs "2 items"
		(
		    // Count value
		    count_reference: NUMERIC,
		
		    // Singular form (e.g., "item")
		    singular: STRING,
		
		    // Plural form (e.g., "items")
		    plural: STRING
		) =>
		    VAR _Word = IF( ABS( count_reference ) = 1, singular, plural )
		
		    RETURN
		        FORMAT( count_reference, "#,##0" ) & " " & _Word
	lineageTag: 08e88a7d-218f-4685-b060-b67723b48c05

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Convert decimals to simple fractions
/// Returns fractions like "1/2", "3/4", "2 1/3"
function 'DaxLib.FormatString.Basic.Fractions' =
		
		// Convert decimals to simple fractions
		// Returns fractions like "1/2", "3/4", "2 1/3"
		() =>
		    VAR _WholeNumber = INT( SELECTEDMEASURE () )
		    VAR _DecimalPart = SELECTEDMEASURE () - _WholeNumber
		
		    VAR _CommonFractions =
		        SWITCH (
		            TRUE (),
		            ABS( _DecimalPart - 0.5 ) < 0.01, "1/2",
		            ABS( _DecimalPart - 0.25 ) < 0.01, "1/4",
		            ABS( _DecimalPart - 0.75 ) < 0.01, "3/4",
		            ABS( _DecimalPart - 0.33333 ) < 0.01, "1/3",
		            ABS( _DecimalPart - 0.66667 ) < 0.01, "2/3",
		            ABS( _DecimalPart - 0.125 ) < 0.01, "1/8",
		            ABS( _DecimalPart - 0.375 ) < 0.01, "3/8",
		            ABS( _DecimalPart - 0.625 ) < 0.01, "5/8",
		            ABS( _DecimalPart - 0.875 ) < 0.01, "7/8",
		            FORMAT( _DecimalPart, "0.00" )
		        )
		
		    RETURN
		        IF ( _WholeNumber = 0,
		            _CommonFractions,
		            FORMAT( _WholeNumber, "#,##0" ) &
		            IF ( _DecimalPart <> 0, " " & _CommonFractions, "" )
		        )
	lineageTag: 5dd94e0d-68ed-4973-a255-8b61b41ae392

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Convert numbers to Roman numerals
/// Returns Roman numerals like "I", "II", "III", "IV", "V", "X", "L", "C", "M"
function 'DaxLib.FormatString.Basic.RomanNumerals' =
		
		// Convert numbers to Roman numerals
		// Returns Roman numerals like "I", "II", "III", "IV", "V", "X", "L", "C", "M"
		() =>
		    VAR _Num = MAX( 1, MIN( 3999, ABS( SELECTEDMEASURE () ) ) )
		
		    VAR _Thousands = INT( _Num / 1000 )
		    VAR _Hundreds = INT( MOD( _Num, 1000 ) / 100 )
		    VAR _Tens = INT( MOD( _Num, 100 ) / 10 )
		    VAR _Ones = MOD( _Num, 10 )
		
		    VAR _ThousandsRoman = REPT( "M", _Thousands )
		
		    VAR _HundredsRoman =
		        SWITCH ( _Hundreds, 1, "C", 2, "CC", 3, "CCC", 4, "CD", 5, "D", 6, "DC", 7, "DCC", 8, "DCCC", 9, "CM", "" )
		
		    VAR _TensRoman =
		        SWITCH ( _Tens, 1, "X", 2, "XX", 3, "XXX", 4, "XL", 5, "L", 6, "LX", 7, "LXX", 8, "LXXX", 9, "XC", "" )
		
		    VAR _OnesRoman =
		        SWITCH ( _Ones, 1, "I", 2, "II", 3, "III", 4, "IV", 5, "V", 6, "VI", 7, "VII", 8, "VIII", 9, "IX", "" )
		
		    VAR _FormatString =
		        DaxLib.FormatString.Component.MakeStringSafe (
		            _ThousandsRoman &
		            _HundredsRoman &
		            _TensRoman &
		            _OnesRoman
		        )
		
		    RETURN
		        _FormatString
	lineageTag: 55f2a253-21ed-4d26-accf-0bccb3429687

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 0.1.2

/// Function that converts a filtered date range into a clear, presentation-style title.
/// Example: 10/1/2023–6/30/2024 -> "Revenue Qtr 4'23 – Qtr 2'24 (3 Qtrs)"
/// Parameters: prefix (e.g. "Revenue"), date column (e.g. 'Calendar'[Date]).
function 'PiotrBartela.TitleContext.Period' =
		(
			Title : STRING,
			DateCol : ANYREF
		) =>
		
		
		-- Date Definitions --
		VAR _Td =
			TODAY()
		VAR _MinDate =
			MIN ( DateCol )
		VAR _MaxDate =
			MAX ( DateCol )
		VAR _MinDateDay =
			DAY ( _MinDate )
		VAR _MinDateMonth =
			MONTH ( _MinDate )
		VAR _MinDateQuarter =
			QUARTER ( _MinDate )
		VAR _MinDateYear =
			YEAR ( _MinDate )
		VAR _MaxDateDay =
			DAY ( _MaxDate )
		VAR _MaxDateMonth =
			MONTH ( _MaxDate )
		VAR _MaxDateQuarter =
			QUARTER ( _MaxDate )
		VAR _MaxDateYear =
			YEAR ( _MaxDate )
		VAR _TdDay =
			DAY ( _Td )
		VAR _TdMonth =
			MONTH ( _Td )
		VAR _TdQuarter =
			QUARTER ( _Td )
		VAR _TdYear =
			YEAR ( _Td )
		
		
		-- Counts for text display --
		VAR _CountDays =
			COUNTROWS ( VALUES ( DateCol ) )
		VAR _Ydiff = 1 + _MaxDateYear - _MinDateYear
		VAR _Qdiff = 1 + ( _MaxDateQuarter - _MinDateQuarter ) + ( ( _MaxDateYear - _MinDateYear ) * 4 )
		VAR _Mdiff = 1 + ( _MaxDateMonth - _MinDateMonth ) + ( ( _MaxDateYear - _MinDateYear ) * 12 )
		
		
		-- Logic Checks --
		VAR _IsNotCorrect =
			_MinDate = BLANK ()
		VAR _IsContinuous =
			VAR _FullSpan =
				DATEDIFF ( _MinDate, _MaxDate, DAY ) + 1
			RETURN
				_CountDays = _FullSpan
		VAR _IsOneCalYear = _MinDateDay = 1
			&& _MinDateMonth = 1
			&& _MaxDateDay = 31
			&& _MaxDateMonth = 12
			&& _MinDateYear = _MaxDateYear
		VAR _IsMulCalYear = _MinDateDay = 1
			&& _MinDateMonth = 1
			&& _MaxDateDay = 31
			&& _MaxDateMonth = 12
		VAR _IsOneCalQuarter = _MinDateDay = 1
			&& ( _MinDateMonth = 1
			|| _MinDateMonth = 4
			|| _MinDateMonth = 7
			|| _MinDateMonth = 10 )
			&& ( ( _MaxDateDay = 31
			&& _MaxDateMonth = 3 )
			|| ( _MaxDateDay = 30
			&& _MaxDateMonth = 6 )
			|| ( _MaxDateDay = 30
			&& _MaxDateMonth = 9 )
			|| ( _MaxDateDay = 31
			&& _MaxDateMonth = 12 ) )
			&& _MinDateQuarter = _MaxDateQuarter
			&& _MinDateYear = _MaxDateYear
		VAR _IsMulQuarters_SameYear = _MinDateDay = 1
			&& ( _MinDateMonth = 1
			|| _MinDateMonth = 4
			|| _MinDateMonth = 7
			|| _MinDateMonth = 10 )
			&& ( ( _MaxDateDay = 31
			&& _MaxDateMonth = 3 )
			|| ( _MaxDateDay = 30
			&& _MaxDateMonth = 6 )
			|| ( _MaxDateDay = 30
			&& _MaxDateMonth = 9 )
			|| ( _MaxDateDay = 31
			&& _MaxDateMonth = 12 ) )
			&& _MinDateYear = _MaxDateYear
		VAR _IsMulQuarters_DiffYear = _MinDateDay = 1
			&& ( _MinDateMonth = 1
			|| _MinDateMonth = 4
			|| _MinDateMonth = 7
			|| _MinDateMonth = 10 )
			&& ( ( _MaxDateDay = 31
			&& _MaxDateMonth = 3 )
			|| ( _MaxDateDay = 30
			&& _MaxDateMonth = 6 )
			|| ( _MaxDateDay = 30
			&& _MaxDateMonth = 9 )
			|| ( _MaxDateDay = 31
			&& _MaxDateMonth = 12 ) )
		VAR _IsOneCalMonth =
			_MinDateDay = 1
			&& _MaxDate = EOMONTH ( _MinDate, 0 )
		VAR _IsMulCalMonth_SameYear =
			_MinDateDay = 1
			&& _MaxDate = EOMONTH ( _MaxDate, 0 )
			&& _MinDateYear = _MaxDateYear
		VAR _IsMulCalMonth_MultYear =
			_MinDateDay = 1
			&& _MaxDate = EOMONTH ( _MaxDate, 0 )
		VAR _IsYTD = _MinDateDay = 1
			&& _MinDateMonth = 1
			&& _MinDateYear = _MaxDateYear
			&& _MinDate <> _MaxDate
			&& _MaxDateQuarter <> 1
		VAR _IsQTD = _MinDateDay = 1
			&& ( _MinDateMonth = 1
			|| _MinDateMonth = 4
			|| _MinDateMonth = 7
			|| _MinDateMonth = 10 )
			&& _MinDateQuarter = _MaxDateQuarter
			&& _MinDateYear = _MaxDateYear
			&& _MinDateMonth <> _MaxDateMonth
			&& _MinDate <> _MaxDate
		VAR _IsMTD = _MinDateDay = 1
			&& _MinDateMonth = _MaxDateMonth
			&& _MinDateYear = _MaxDateYear
			&& _MinDate <> _MaxDate
		VAR _IsOneDay = _CountDays = 1
		VAR _IsMulDays_SameMonth = _MinDateMonth = _MaxDateMonth
			&& _MinDateYear = _MaxDateYear
		VAR _IsMulDays_SameYear = _MinDateYear = _MaxDateYear
		
		-- Relative check --
		VAR _Is_L_Y = _TdYear - 1 = _MaxDateYear
		VAR _Is_T_Y = _TdYear = _MaxDateYear
		VAR _Is_L_Q =
			IF (
				_TdYear = _MaxDateYear,
				_TdQuarter - 1 = _MaxDateQuarter,
				( _TdQuarter = 1
					&& _MaxDateQuarter = 4 )
			)
		VAR _Is_T_Q = ( _TdQuarter = _MaxDateQuarter )
			&& ( _TdYear = _MaxDateYear )
		VAR _Is_L_M =
			IF (
				_TdYear = _MaxDateYear,
				_TdMonth - 1 = _MaxDateMonth,
				( _TdMonth = 1
					&& _MaxDateMonth = 12 )
			)
		VAR _Is_T_M = ( _TdMonth = _MaxDateMonth )
			&& ( _TdYear = _MaxDateYear )
		VAR _Is_L_D = _Td - 1 = _MaxDate
		VAR _Is_T_D = _Td = _MaxDate
		
		
		-- Text strings --
		VAR _OneY = _MinDateYear
		VAR _MulY = _MinDateYear & " - " & _MaxDateYear & " (" & _Ydiff & " Years)"
		VAR _OneQ = _MinDateYear & " Qtr " & _MinDateQuarter
		VAR _MulQ_SY = _MinDateYear & " Qtr " & _MinDateQuarter & " - Qtr " & _MaxDateQuarter & " (" & _Qdiff & " Qtrs)"
		VAR _MulQ_DY =
			"Qtr " & _MinDateQuarter & "'"
				& RIGHT ( _MinDateYear, 2 ) & " - Qtr " & _MaxDateQuarter & "'"
				& RIGHT ( _MaxDateYear, 2 ) & " (" & _Qdiff & " Qtrs)"
		VAR _OneM =
			FORMAT ( _MinDate, "yyyy MMMM" )
		VAR _MulM_SY =
			_MinDateYear & " "
				& FORMAT ( _MinDate, "MMMM" ) & " - "
				& FORMAT ( _MaxDate, "MMMM" ) & " (" & _Mdiff & " Mts)"
		VAR _MulM_DY =
			_MinDateYear & " "
				& FORMAT ( _MinDate, "MMM" ) & " - " & _MaxDateYear & " "
				& FORMAT ( _MaxDate, "MMM" ) & " (" & _Mdiff & " Mts)"
		VAR _YTD =
			"YTD " & _MinDateYear & " up to "
				& FORMAT ( _MaxDate, "MMMM d" )
		VAR _QTD =
			"QTD " & FORMAT ( _MinDate, "Q'yy" ) & " up to "
				& FORMAT ( _MaxDate, "MMMM d" )
		VAR _MTD =
			"MTD " & FORMAT ( _MaxDate, "yyyy MMMM d" )
		VAR _OneD =
			FORMAT ( _MinDate, "yyyy MMMM dd" )
		VAR _MulD_SM =
			FORMAT ( _MinDate, "yyyy MMMM d" ) & " - " & _MaxDateDay & " (" & _CountDays & " Days)"
		VAR _MulD_SY =
			FORMAT ( _MinDate, "yyyy MMM d" ) & " - "
				& FORMAT ( _MaxDate, "MMM d" ) & " (" & _CountDays & " Days)"
		VAR _MulD_DY = _MinDate & " - " & _MaxDate & " (" & _CountDays & " Days)"
		
		
		-- Rel Strings --
		VAR _L_OneY = "Last Year (" & _MinDateYear & ")"
		VAR _YTD_R =
			"Current YTD (" & _MinDateYear & ")" & " up to "
				& FORMAT ( _MaxDate, "MMMM d" )
		VAR _L_MulY = "Last " & _Ydiff & " Years (" & _MinDateYear & " - " & _MaxDateYear & ")"
		VAR _L_OneQ = "Last Quarter (" & _MinDateYear & " Qtr " & _MinDateQuarter & ")"
		VAR _QTD_R =
			"Current QTD (" & FORMAT ( _MinDate, "Q'yy" ) & ") up to "
				& FORMAT ( _MaxDate, "MMMM d" )
		VAR _L_MulQ_SY = "Last " & _Qdiff & "Q (" & _MinDateYear & " Qtr " & _MinDateQuarter & " - Qtr " & _MaxDateQuarter & ")"
		VAR _L_MulQ_DY =
			"Last " & _Qdiff & "Q (Qtr " & _MinDateQuarter & "'"
				& RIGHT ( _MinDateYear, 2 ) & " - Qtr " & _MaxDateQuarter & "'"
				& RIGHT ( _MaxDateYear, 2 ) & ")"
		VAR _L_OneM =
			"Last Month (" & FORMAT ( _MinDate, "yyyy MMMM" ) & ")"
		VAR _T_OneM =
			"This Month (" & _MinDateYear & " "
				& FORMAT ( _MinDate, "MMMM" ) & ")"
		VAR _MTD_R =
			"Current MTD " & FORMAT ( _MaxDate, "yyyy MMMM d" )
		VAR _L_MulM_SY =
			"Last " & _Mdiff & " Mts (" & _MinDateYear & " "
				& FORMAT ( _MinDate, "MMMM" ) & " - "
				& FORMAT ( _MaxDate, "MMMM" ) & ")"
		VAR _L_MulM_DY =
			"Last " & _Mdiff & " Mts ("
				& FORMAT ( _MinDate, "MMM'yy" ) & " - "
				& FORMAT ( _MaxDate, "MMM'yy" ) & ")"
		VAR _Yesterday =
			"Yesterday (" & FORMAT ( _MinDate, "yyyy MMMM dd" ) & ")"
		VAR _Today =
			"Today (" & FORMAT ( _MinDate, "yyyy MMMM dd" ) & ")"
		VAR _L_MulD_SM =
			"Last " & _CountDays & " Days ("
				& FORMAT ( _MinDate, "yyyy MMMM d" ) & " - " & _MaxDateDay & ")"
		VAR _L_MulD_SY =
			"Last " & _CountDays & " Days ("
				& FORMAT ( _MinDate, "yyyy MMM d" ) & " - "
				& FORMAT ( _MaxDate, "MMM d" ) & ")"
		VAR _L_MulD_DY = "Last " & _CountDays & " Days (" & _MinDate & " - " & _MaxDate & ")"
		VAR _DateResult =
			SWITCH (
				TRUE (),
				_IsOneCalYear, IF ( _Is_L_Y, _L_OneY, _OneY ),
				_IsMulCalYear, IF ( _Is_L_Y, _L_MulY, _MulY ),
				_IsOneCalQuarter, IF ( _Is_L_Q, _L_OneQ, _OneQ ),
				_IsMulQuarters_SameYear, IF ( _Is_L_Q, _L_MulQ_SY, _MulQ_SY ),
				_IsMulQuarters_DiffYear, IF ( _Is_L_Q, _L_MulQ_DY, _MulQ_DY ),
				_IsOneCalMonth, IF ( _Is_L_M, _L_OneM, _OneM ),
				_IsMulCalMonth_SameYear, IF ( _Is_L_M, _L_MulM_SY, _MulM_SY ),
				_IsMulCalMonth_MultYear, IF ( _Is_L_M, _L_MulM_DY, _MulM_DY ),
				_IsYTD, IF ( _Is_T_Y, _YTD_R, _YTD ),
				_IsQTD, IF ( _Is_T_Q, _QTD_R, _QTD ),
				_IsMTD, IF ( _Is_T_M, _MTD_R, _MTD ),
				_IsOneDay, IF ( _Is_T_D, _Today, IF ( _Is_L_D, _Yesterday, _OneD ) ),
				_IsMulDays_SameMonth, IF ( _Is_L_D, _L_MulD_SM, _MulD_SM ),
				_IsMulDays_SameYear, IF ( _Is_L_D, _L_MulD_SY, _MulD_SY ),
				IF ( _Is_L_D, _L_MulD_DY, _MulD_DY )
			)
		
		
		-- Final Result Variables --
		VAR _NcSum = "(" & _CountDays & " days total)"
		VAR _NotContinuousText = Title & " " & "in multiple periods " & _NcSum
		VAR _NotCorrectTimeframe = "Choose correct timeframe"
		VAR _ResultText = Title & " " & _DateResult
		
		
		-- Result --
		VAR _Result =
			SWITCH (
				TRUE (),
				_IsNotCorrect, _NotCorrectTimeframe,
				NOT _IsContinuous, _NotContinuousText,
				_ResultText
			)
		RETURN
			_Result
	lineageTag: 9908b505-679c-4cc4-93c6-0480133bb57a

	annotation DAXLIB_PackageId = PiotrBartela.TitleContext

	annotation DAXLIB_PackageVersion = 0.2.0

/// Description: Function that will display in one string current filters.
/// Prerequisit: You have to create dummy column first eg. 'Dummy'[Dummy] (anyref can't be BLANK as for now)
/// Tip: set TestMode parameter to 1 to adjust maximum length of a final string.
/// Example: PiotrBartela.TitleContext.Filtered(70,0,"First filter name",'Table1'[Column1],"",'Dummy'[Dummy],"",'Dummy'[Dummy],"",'Dummy'[Dummy],"",'Dummy'[Dummy])
function 'PiotrBartela.TitleContext.Filtered' =
				(
		            MaxLength:int64,
		            TestMode:boolean,
		            Name1:string,
		            Col1:anyref,
		            Name2:string,
		            Col2:anyref,
		            Name3:string,
		            Col3:anyref,
		            Name4:string,
		            Col4:anyref,
		            Name5:string,
		            Col5:anyref
				)  =>
		
					VAR _testing_numbers = "111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999000000000011111111112222222222333333333344444444445555555555666666666677777777778888888888999999999900000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999000000000011111111112222222222333333333344444444445555555555666666666677777777778888888888999999999900000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999000000000011111111112222222222333333333344444444445555555555666666666677777777778888888888999999999900000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999000000000011111111112222222222333333333344444444445555555555666666666677777777778888888888999999999900000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999000000000011111111112222222222333333333344444444445555555555666666666677777777778888888888999999999900000000001111111111222222222233333333334444444444555555555566666666667777777777888888888899999999990000000000"
		
					VAR _test_text = LEFT(_testing_numbers,MaxLength)
		
					VAR _no_filters = "All Sales, Globally" // adjust if needed
		
					VAR _1_is = ISFILTERED(Col1)
					VAR _1 = CONCATENATEX(VALUES(Col1),Col1,", ")
					VAR _1_num = COUNTROWS(VALUES(Col1))
		
					VAR _1_len = LEN(_1)
					VAR _1_first = MINX(
						TOPN(1,VALUES(Col1),Col1),Col1)
					VAR _1_second = MINX(
						TOPN(2,VALUES(Col1),Col1),Col1)
					VAR _1_third = MINX(
						TOPN(3,VALUES(Col1),Col1),Col1)
		
					VAR _1_text_v1 = IF(_1_is,"" & Name1 & ": " & _1 & " | ","")
					VAR _1_text_v2 = IF(
						_1_is,
						SWITCH(TRUE(),
							_1_num = 1,"" & Name1 & ": " & _1_first & " | ",
							_1_num = 2,"" & Name1 & ": " & _1_first & ", "& _1_second & " | ",
							_1_num = 3,"" & Name1 & ": " & _1_first & ", " & _1_second & ", " & _1_third & " | ",
							"" &Name1 & ": " & _1_first & ", " & _1_second & ", " & _1_third & " (+" & _1_num - 3 & ")" & " | "),
						"")
					VAR _1_text_v3 = IF(
						_1_is,
						SWITCH(TRUE(),
							_1_num = 1,"" & Name1 & ": " & _1_first & " | ",
							_1_num = 2,"" & Name1 & ": " & _1_first & ", "& _1_second & " | ",
							"" &Name1 & ": " & _1_first & ", " & _1_second & " (+" & _1_num - 2 & ")" & " | "),
						"")
					VAR _1_text_v4 = IF(
						_1_is,
						SWITCH(TRUE(),
							_1_num = 1,"" & Name1 & ": " & _1_first & " | ",
							"" &Name1 & ": " & _1_first & " (+" & _1_num - 1 & ")" & " | "),
						"")
					VAR _1_text_v5 = IF(
						_1_is,
						"" & Name1 & " (" & _1_num & ")" & " | ",
						"")
		
		
					VAR _2_is = ISFILTERED(Col2)
					VAR _2 = CONCATENATEX(VALUES(Col2),Col2,", ")
					VAR _2_num = COUNTROWS(VALUES(Col2))
		
					VAR _2_len = LEN(_2)
					VAR _2_first = MINX(
						TOPN(1,VALUES(Col2),Col2),Col2)
					VAR _2_second = MINX(
						TOPN(2,VALUES(Col2),Col2),Col2)
					VAR _2_third = MINX(
						TOPN(3,VALUES(Col2),Col2),Col2)
		
					VAR _2_text_v1 = IF(_2_is,"" & Name2 & ": " & _2 & " | ","")
					VAR _2_text_v2 = IF(
						_2_is,
						SWITCH(TRUE(),
							_2_num = 1,"" & Name2 & ": " & _2_first & " | ",
							_2_num = 2,"" & Name2 & ": " & _2_first & ", "& _2_second & " | ",
							_2_num = 3,"" & Name2 & ": " & _2_first & ", " & _2_second & ", " & _2_third & " | ",
							"" &Name2 & ": " & _2_first & ", " & _2_second & ", " & _2_third & " (+" & _2_num - 3 & ")" & " | "),
						"")
					VAR _2_text_v3 = IF(
						_2_is,
						SWITCH(TRUE(),
							_2_num = 1,"" & Name2 & ": " & _2_first & " | ",
							_2_num = 2,"" & Name2 & ": " & _2_first & ", "& _2_second & " | ",
							"" &Name2 & ": " & _2_first & ", " & _2_second & " (+" & _2_num - 2 & ")" & " | "),
						"")
					VAR _2_text_v4 = IF(
						_2_is,
						SWITCH(TRUE(),
							_2_num = 1,"" & Name2 & ": " & _2_first & " | ",
							"" &Name2 & ": " & _2_first & " (+" & _2_num - 1 & ")" & " | "),
						"")
					VAR _2_text_v5 = IF(
						_2_is,
						"" & Name2 & " (" & _2_num & ")" & " | ",
						"")
		
		
					VAR _3_is = ISFILTERED(Col3)
					VAR _3 = CONCATENATEX(VALUES(Col3),Col3,", ")
					VAR _3_num = COUNTROWS(VALUES(Col3))
		
					VAR _3_len = LEN(_3)
					VAR _3_first = MINX(
						TOPN(1,VALUES(Col3),Col3),Col3)
					VAR _3_second = MINX(
						TOPN(2,VALUES(Col3),Col3),Col3)
					VAR _3_third = MINX(
						TOPN(3,VALUES(Col3),Col3),Col3)
		
					VAR _3_text_v1 = IF(_3_is,"" & Name3 & ": " & _3 & " | ","")
					VAR _3_text_v2 = IF(
						_3_is,
						SWITCH(TRUE(),
							_3_num = 1,"" & Name3 & ": " & _3_first & " | ",
							_3_num = 2,"" & Name3 & ": " & _3_first & ", "& _3_second & " | ",
							_3_num = 3,"" & Name3 & ": " & _3_first & ", " & _3_second & ", " & _3_third & " | ",
							"" &Name3 & ": " & _3_first & ", " & _3_second & ", " & _3_third & " (+" & _3_num - 3 & ")" & " | "),
						"")
					VAR _3_text_v3 = IF(
						_3_is,
						SWITCH(TRUE(),
							_3_num = 1,"" & Name3 & ": " & _3_first & " | ",
							_3_num = 2,"" & Name3 & ": " & _3_first & ", "& _3_second & " | ",
							"" &Name3 & ": " & _3_first & ", " & _3_second & " (+" & _3_num - 2 & ")" & " | "),
						"")
					VAR _3_text_v4 = IF(
						_3_is,
						SWITCH(TRUE(),
							_3_num = 1,"" & Name3 & ": " & _3_first & " | ",
							"" &Name3 & ": " & _3_first & " (+" & _3_num - 1 & ")" & " | "),
						"")
					VAR _3_text_v5 = IF(
						_3_is,
						"" & Name3 & " (" & _3_num & ")" & " | ",
						"")
		
					VAR _4_is = ISFILTERED(Col4)
					VAR _4 = CONCATENATEX(VALUES(Col4),Col4,", ")
					VAR _4_num = COUNTROWS(VALUES(Col4))
		
					VAR _4_len = LEN(_4)
					VAR _4_first = MINX(
						TOPN(1,VALUES(Col4),Col4),Col4)
					VAR _4_second = MINX(
						TOPN(2,VALUES(Col4),Col4),Col4)
					VAR _4_third = MINX(
						TOPN(3,VALUES(Col4),Col4),Col4)
		
					VAR _4_text_v1 = IF(_4_is,"" & Name4 & ": " & _4 & " | ","")
					VAR _4_text_v2 = IF(
						_4_is,
						SWITCH(TRUE(),
							_4_num = 1,"" & Name4 & ": " & _4_first & " | ",
							_4_num = 2,"" & Name4 & ": " & _4_first & ", "& _4_second & " | ",
							_4_num = 3,"" & Name4 & ": " & _4_first & ", " & _4_second & ", " & _4_third & " | ",
							"" &Name4 & ": " & _4_first & ", " & _4_second & ", " & _4_third & " (+" & _4_num - 3 & ")" & " | "),
						"")
					VAR _4_text_v3 = IF(
						_4_is,
						SWITCH(TRUE(),
							_4_num = 1,"" & Name4 & ": " & _4_first & " | ",
							_4_num = 2,"" & Name4 & ": " & _4_first & ", "& _4_second & " | ",
							"" &Name4 & ": " & _4_first & ", " & _4_second & " (+" & _4_num - 2 & ")" & " | "),
						"")
					VAR _4_text_v4 = IF(
						_4_is,
						SWITCH(TRUE(),
							_4_num = 1,"" & Name4 & ": " & _4_first & " | ",
							"" &Name4 & ": " & _4_first & " (+" & _4_num - 1 & ")" & " | "),
						"")
					VAR _4_text_v5 = IF(
						_4_is,
						"" & Name4 & " (" & _4_num & ")" & " | ",
						"")
		
					VAR _5_is = ISFILTERED(Col5)
					VAR _5 = CONCATENATEX(VALUES(Col5),Col5,", ")
					VAR _5_num = COUNTROWS(VALUES(Col5))
		
					VAR _5_len = LEN(_5)
					VAR _5_first = MINX(
						TOPN(1,VALUES(Col5),Col5),Col5)
					VAR _5_second = MINX(
						TOPN(2,VALUES(Col5),Col5),Col5)
					VAR _5_third = MINX(
						TOPN(3,VALUES(Col5),Col5),Col5)
		
					VAR _5_text_v1 = IF(_5_is,"" & Name5 & ": " & _5 & " | ","")
					VAR _5_text_v2 = IF(
						_5_is,
						SWITCH(TRUE(),
							_5_num = 1,"" & Name5 & ": " & _5_first & " | ",
							_5_num = 2,"" & Name5 & ": " & _5_first & ", "& _5_second & " | ",
							_5_num = 3,"" & Name5 & ": " & _5_first & ", " & _5_second & ", " & _5_third & " | ",
							"" &Name5 & ": " & _5_first & ", " & _5_second & ", " & _5_third & " (+" & _5_num - 3 & ")" & " | "),
						"")
					VAR _5_text_v3 = IF(
						_5_is,
						SWITCH(TRUE(),
							_5_num = 1,"" & Name5 & ": " & _5_first & " | ",
							_5_num = 2,"" & Name5 & ": " & _5_first & ", "& _5_second & " | ",
							"" &Name5 & ": " & _5_first & ", " & _5_second & " (+" & _5_num - 2 & ")" & " | "),
						"")
					VAR _5_text_v4 = IF(
						_5_is,
						SWITCH(TRUE(),
							_5_num = 1,"" & Name5 & ": " & _5_first & " | ",
							"" &Name5 & ": " & _5_first & " (+" & _5_num - 1 & ")" & " | "),
						"")
					VAR _5_text_v5 = IF(
						_5_is,
						"" & Name5 & " (" & _5_num & ")" & " | ",
						"")
		
					VAR _total_f_count = IF(_1_is,_1_num,0) + IF(_2_is,_2_num,0) + IF(_3_is,_3_num,0) + IF(_4_is,_4_num,0) + IF(_5_is,_5_num,0)
		
					VAR _full_text_v1 = FORMAT(_1_text_v1 & _2_text_v1 & _3_text_v1 & _4_text_v1 & _5_text_v1,"")
					VAR _full_text_v2 = FORMAT(_1_text_v2 & _2_text_v2 & _3_text_v2 & _4_text_v2 & _5_text_v2,"")
					VAR _full_text_v3 = FORMAT(_1_text_v3 & _2_text_v3 & _3_text_v3 & _4_text_v3 & _5_text_v3,"")
					VAR _full_text_v4 = FORMAT(_1_text_v4 & _2_text_v4 & _3_text_v4 & _4_text_v4 & _5_text_v4,"")
					VAR _full_text_v5 = FORMAT("Filters: " & _1_text_v5 & _2_text_v5 & _3_text_v5 & _4_text_v5 & _5_text_v5,"")
					VAR _full_text_v6 = FORMAT("Total Filters Applied: " & FORMAT(_total_f_count,"0") & " | ","")
		
					VAR _v1_len = LEN(_full_text_v1)
					VAR _v2_len = LEN(_full_text_v2)
					VAR _v3_len = LEN(_full_text_v3)
					VAR _v4_len = LEN(_full_text_v4)
					VAR _v5_len = LEN(_full_text_v5)
		
		
					VAR _full_text_adjusted = SWITCH(True(),
						_v1_len <= MaxLength, FORMAT(_full_text_v1,""),
						_v2_len <= MaxLength, FORMAT(_full_text_v2,""),
						_v3_len <= MaxLength, FORMAT(_full_text_v3,""),
						_v4_len <= MaxLength, FORMAT(_full_text_v4,""),
						_v5_len <= MaxLength, FORMAT(_full_text_v5,""),
						_full_text_v6)
		
		
					VAR _full_text_trimed = "" & LEFT(_full_text_adjusted, LEN(_full_text_adjusted) - 2)
		
					VAR _is_filter = _1_is || _2_is || _3_is || _4_is || _5_is
		
					VAR _Result = IF(testmode,_test_text,FORMAT(IF(_is_filter, _full_text_trimed, _no_filters),""))
		
					RETURN
					    _Result
	lineageTag: 7300c18f-e4db-4c42-991f-dbea56358d48

	annotation DAXLIB_PackageId = PiotrBartela.TitleContext

	annotation DAXLIB_PackageVersion = 0.2.0

function 'Jespervb7.TimeIntelligence._PreviousMonth' = ```
		
			(
				pMeasureValue : anyref
			) =>
		
			
			VAR _Result = CALCULATE(pMeasureValue, PREVIOUSMONTH('Dim Date'[Date]))
			
			RETURN _Result
		```
	lineageTag: a82c1eda-5078-46b7-a116-6889f9c595f7

function 'Jespervb7.PercentDifference' =
		(
		            pCurrentValue : SCALAR,
		            pPreviousValue : SCALAR
		        ) =>
		        VAR _NewMinusOld = pCurrentValue - pPreviousValue
		        VAR _Result =
		            DIVIDE (
		                _NewMinusOld,
		                pPreviousValue
		            )
		        RETURN
		            _Result
	lineageTag: 8c20c8f7-6ed7-4484-a48a-e636b428f4a4

